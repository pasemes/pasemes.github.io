---
layout: post
title: "Was Test-Driven Development ever alive? The reality regarding its impacts on the productivity and quality"
tags: [meta-analysis, synthesis, test first, test-driven development]
bigimg: /img/blog/DecisonMakingTree.jpg
date: 2017-05-12 12:00:00 -0300
permalink: /blog/was-tdd-ever-alive/
layout: post
comments: true
show-share: true
show-subscribe: true
---

#The origin and the expected benefits of TDD

TDD was rediscovered by Kent Back and thoroughly presented in his famous book "Test Driven Development: By Example". It was initially put among the cornerstone practices of the Extreme Programming (XP) development process, but it became so popular that was adopted as a stand-alone agile practice. In a period when software testing was regarded as something for mature organizations performed usually at the end of lengthy releases, the rediscovery of TDD was an important instrument to support the introduction of some agile principles emerging at the time.  The basic idea attributed to TDD is to provide a continuous feedback regarding the current state of your development process in terms of the source code design improvement and defects expectancy reduction. As a result, TDD is extremely useful for several agile practices particularly those concerned with the short iterative nature of agile methods such as welcoming changes, maintaining a constant pace, and assessing the progress of working software. For this reason, its main expected benefits are:

* Work with confidence;
* Work on a series of achievable steps instead of tackling a big problem all at once;
* Ensure that software design meets the need of the actual code;
* Leave behind a suite of tests to help preserve the integrity of the code.

Despite the improvements associated with TDD, there are several possible drawbacks 


There are four primary notions that imperative for practice TDD: (i) testing before code, (ii) automation, (iii) refactoring, and (iv) baby-steps. From those, the most controversy is arguably associated with testing 

However, despite these  suas promessas para sua disciplina requer dois passos cruciais. 1) automation 2) baby-steps 

1. Design and add an automated test.
1. Run all tests and see the new one fail (red).
1. Add enough implementation code to satisfy the new test.
1. Run all tests, repeat 3 if necessary until all tests pass (green).
1. Occasionally refactor to improve code structure.
1. Run all tests after refactoring to ensure all tests pass.


#The controversy: "TDD is dead. Long live testing"








